---
title: 'npm v7, package-lock v2 그리고 yarn.lock'
tags:
  - javascript
  - npm
  - nodejs
published: false
date: 2020-11-04 20:18:34
description: '사고 친 기념으로 작성'
---

아직 생태계가 따라가려면 멀었지만, npm v7이 릴리즈 되었다. 눈여겨 볼 만한 점은 모노레포 환경을 꾸며 볼 수 있는 `npm workspace`와 `yarn.lock`의 지원이다. `npm workspace`는 시간이 나면 차차 실험해 보는 걸로 하고, 이번 포스트에서는 `yarn.lock`파일을 지원하는 이유와 `package-lock v2`에 대한 내용이다.

내용의 대부분은 https://blog.npmjs.org/post/621733939456933888/npm-v7-series-why-keep-package-lockjson 에서 참고 했으며, 몇가지 개인적인 실험도 추가했다.

npm v7은 `yarn.lock`을 지원하기 시작헀다. 그럼에도 `package-lock.json`은 살아남았다. 그 이유에 대해서, `yarn.lock`은 npm의 요구를 완전히 채우지 못한다고 이야기 하고 있다.

> The simple answer is: because yarn.lock doesn’t fully address npm’s needs, and relying on it exclusively would limit our ability to produce optimal package installs or add features in the future.

`yarn.lock` 의 구조는 대략 아래와 같다.

```bash
mkdirp@1.x:
  version "1.0.2"
  resolved "https://registry.yarnpkg.com/mkdirp/-/mkdirp-1.0.2.tgz#5ccd93437619ca7050b538573fc918327eba98fb"
  integrity sha512-N2REVrJ/X/jGPfit2d7zea2J1pf7EAR5chIUcfHffAZ7gmlam5U65sAm76+o4ntQbSRdTjYf7qZz3chuHlwXEA==
```

이는 "`mkdirp@1.x`에 대한 모든 의존성은 정확히 이것을 사용해야 한다"는 것을 의미한다. 여러 패키지가 `mkdirp@1.x`에 의존하면, 모두 이 의존성을 사용하게 된다.

`npm v7` 부터는, `yarn.lock`이 있을 경우 이 메타데이터를 사용한다. 의존성에 따라서 가져올 패키지를 알려주고, 무결성을 사용하여 결과 값이 일치하는지 확인한다. 패키지가 추가되거나 제거되면 `yarn.lock` 파일을 업데이트 한다.

`npm`은 그럼에도 불구하고 여전히 `package-lock.json`을 생성하고, 해당 파일이 이미 존재할 경우 트리를 만들 수 있는 권한이 있는 값으로 사용될 것이다.

`yarn`으로도 충분한데, 왜 `package-lock.json`은 여전히 필요한 것일까?

## 결정론적 빌드 결과 (Deterministic Build Results)

아래와 같은 의존성 그래프가 있다고 가정하자.

```bash
root -> (foo@1, bar@1)
foo -> (baz@1)
bar -> (baz@2)
```

이 의존성 그래프는 아래 두개와 같다.

```bash
root
+-- foo
+-- bar
|   +-- baz@2
+-- baz@1
```

```bash
root
+-- foo
|   +-- baz@1
+-- bar
+-- baz@2
```

`yarn.lock`은 어떤 것을 사용해야하는지 알려줄 수 없다. 루트 패키지에서 `baz`가 필요한 경우, 그 결과는 `yarn.lock`에 의해서 보장되지 않는다. 이는 `package-lock.json`에서는 보장해 줄 수 있는 결정론적인 형태이며, `yarn.lock`은 할수가 없다.

물론 실무상에서는, `yarn`이 이러한 선택을 하기 위해 필요한 모든 정보를 `yarn.lock`에 가지고 있으므로, 모두가 같은 버전의 `yarn`을 사용한다면 트리 구조가 결정론적으로 동일해지며, 다른 사람이 바꾸는한 변하지 않는다. 

이는 디스크의 데이터 구조가 아닌 yarn의 알고리즘의 세부사항에 의해서 정의 되기 때문에, 결정론적인 보장은 디스크의 패키지 트리 모양을 완전히 명시하여 제공하는 `package-lock.json`에 비해서 기본적으로 약할 수 밖에 없다. 

https://classic.yarnpkg.com/blog/2017/05/31/determinism/

> npm 5 has stronger guarantees across versions and has a stronger deterministic lockfile, but Yarn only has those guarantees when you’re on the same version in favor of a lighter lockfile that is better for review. It’s possible that there’s a lockfile solution that has the best of both worlds, but for now this is current state of the ecosystem and possible convergence could happen in the future.

아래와 같은 의존성 그래프가 있다고 가정해보자.

```bash
root -> (x@1.x, y@1.x, z@1.x)
x@1.1.0 -> ()
x@1.2.0 -> ()
y@1.0.0 -> (x@1.1, z@2.x)
z@1.0.0 -> ()
z@2.0.0 -> (x@1.x)
```

루트 프로젝트는 `x` `y` `z`의 1.x 버전을 의존하고 있다. `y`는 `x` 1.1과 `z` 2.x를 의존하고 있으며, `z` 1은 의존성이 없지만 2에서는 `x` 1.x를 의존하고 있다. 

npm은 아래와 같은 의존성 그래프를 그린다.

```bash
root (x@1.x, y@1.x, z@1.x) <-- x@1.x dep here
+-- x 1.2.0                <-- x@1.x resolves to 1.2.0
+-- y (x@1.1, z@2.x)
|   +-- x 1.1.0            <-- x@1.x resolves to 1.1.0
|   +-- z 2.0.0 (x@1.x)    <-- x@1.x dep here
+-- z 1.0.0
```

`z` 2.x는 루트와 마찬가지로 `x` 1.x를 의존하고 있다. `yarn.lock`은 `x`의 1.x에 대응하는 `x@1.2.0`을 설치할 것이다. 그러나 `z`에 명시되어 있는 의존성 `x`의 1.x는 `x@1.1.0`을 설치하게 될 것이다.

