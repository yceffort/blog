---
title: 'nodejs의 worker thread'
tags:
  - javascript
  - nodejs
published: false
date: 2020-11-24 23:11:50
description: ''
---

Nodejs의 워커를 이해하기 위해서는, nodejs의 구조를 이해하는 것이 필수적이다.

Nodejs가 실행되면 다음을 함께 실행하게 된다.

- 한개의 프로세스: 프로세스는 어디서나 액세스 할 수 있으며, 한 번 실행시에 가지고 있는 항목에 대한 정보를 가지고 있는 글로벌 객체다.
- 한개의 스레드: 단일 스레드라는 것은, 주어진 프로세스에 서 한번에 하나의 명령 집합만 실행됨을 의미한다.
- 한개의 이벤트 루프: Nodejs에 대해 이해해야할 가장 중요한 요소 중 하나다. 자바스크립트가 싱글 스레드 임에도 불구하고 비동기, Non blocking io를 가질 수 있는 이유는 콜백, 프로미스, async/await 을 통해 가능할 때마다 시스템 커널에 작업을 오프로드 하기 때문이다.
- 한개의 자바스크립트 엔진 인스턴스: 자바스크립트 코드를 실행하는 컴퓨터 프로그램
- 한개의 Nodejs 인스턴스: Nodejs코드를 실행하는 컴퓨터 프로그램

다시 말해, 노드는 싱글 스레드 환경에서 실행되며, 이벤트 루프에서 한 번에 한개의 프로세스만 돌아갈 수 있다는 것을 의미한다. 한개의 코드에서는, 한 번의 실행만 이뤄진다. (코드가 병렬적으로 실행될 수 는 없음) 이는 개발자가 동시성 이슈에 대한 고민을 하지 않고 자바스크립트 코드를 짤 수 있게 도움을 준다.

자바스크립트가 이런식으로 설계된 이유에는, 자바스크립트는 원래 클라이언트 사이드의 인터랙션만 처리하기 위해서 만들어졌기때문이다. (웹페이지와 같은) 그 때문에 멀티스레딩과 같은 복잡한 것에 대한 고려가 들어가 있지 않았다.

하지만 모든 것이 그렇지만, 이러한 설계가 약점이 되기도 한다. 만약 메모리에 있는 큰 데이터셋에 대한 복잡한 연산과 같이, CPU 성능을 적극 활용해야하는 코드가 있을 경우, 다른 프로세스가 실행되는 것을 차단할 수 있다는 약점이 존재한다. 마찬가지로, 서버에 CPU 집약적인 코드에 대한 요청이 이뤄질 경우, 이벤트 블록을 막을 수 있으며, 다른 요청을 처리하는데 방해가 될 수 있다.

만약 메인 이벤트 루프가 다음 코드의 실행이 끝날때까지 기다려야 하는경우, 그 함수는 '블로킹'으로 간주된다. '논블로킹'함수는 메인 이벤트 루프가 실행되자마자 계속 연산할 수 있도록 하며, 일반적으로 콜백을 호출하여 메인 루프가 종료되면 이를 알려 주게 된다.

> 황금률: 이벤트 루프를 차단하지말고, 이벤트루프가 계속 실행될 수 있도록 염두해 두어야 한다. 동기식 네트워크 호출이나 무한 루프 처럼 스레드를 차단할 수 있는 모든 것에 대해 주의하고 이를 가능한 피해야 한다.

CPU 오퍼레이션과 입출력 오퍼레이션을 구분하는 것이 중요하다. 앞서 언급했던 것 처럼, Nodejs 코드는 병렬로 실행되지 않는다. IO 작업의 경우 비동기로 실행되기 때문에 병렬로 실행 될 수 있다.

따라서 워커 스레드는 비동기 IO작업이 워커가 할 수 있는 것 보다 훨씬 더 효율적이기 때문에 IO 집약적인 작업에는 별로 도움이 되지 않는다. 워커의 주 목적은 IO작업이 아닌, CPU집약적인 작업에서 성능을 향상시키는 것이다.

## 몇가지 다른 해결책

더욱이, CPU 집약적인 작업에 대해서는 이미 해결책이 존재한다. CPU가 최적으로 사용되도록 하는 멀티 프로세스 (Cluster API등)가 있다.

이러한 접근 방식은 프로세스의 분리를 허용하기 때문에, 한 프로세스에서 어떤 것이 잘못된다 하더라도 다른 곳에 영향을 미치지 않게 된다. 또한 이러한 안정적이다. 그러나 이는 메모리를 희생해야 한다는 것을 의미하며, 데이터 통신 역시 JSON으로 이루어져야 한다는 단점이 존재한다.

## 자바스크립트와 Nodejs는 절대 쓰레드를 가지지 않는다.

Nodejs 코어에 새로운 모듈을 추가하면, 우리가 스레드를 만들어서 동기화 할 수 도 있고, 따라서 CPU 집약적인 작업도 해결할 수 있을 것이라고 생각할 수 있다.

그러나 그렇지 않다. 만약 쓰레드가 여기에 더 추가된다면, 언어의 성격 자체가 바뀌게 될 것이다. 사용가능한 클래스 또는 함수의 집합으로 스레드를 추가하는 것은 불가능하다. 자바와 같이 멀티스레딩을 지원하는 언어에서는, `synchronized`와 같은 키워드가 여러 스레드를 동기화 할 수 있도록 도와주지만, 자바스크립트에 그런개념은 없다.

또한 일부 숫자 유형은 원자형이 아니다. 이를 동기화 하지 않으면 두개의 스레드가 변수의 값을 변경하여, 결과적으로 두 스레드가 모두 액세스한 변수의 바이트가 한 스레드에 의해 변경될 수 있고, 또 몇 바이트는 다른 스레드에 의해 변경되어 유효한 값이 생성되지 않을 수도 있다는 것을 의미한다. 일례로 자바스크립트에서 `0.1+0.2`는 자바스크립트 최대자리수읜 17자리의 값이 나오게 된다.

> "Atomic operation" means an operation that appears to be instantaneous from the perspective of all other threads. You don't need to worry about a partly complete operation when the guarantee applies.

```javascript
var x = 0.1 + 0.2 // x will be 0.30000000000000004
```

부동소수점 (floating)은 항상 100% 정확하지 않다. 따라서 동기화가 되지 않으면, 한 워커에 의해 숫자가 변경될 수 있고, 이는 동일하지 않은 두 숫자를 만들어낼 가능성이 존재하게 된다.

## 최선의 해결책

CPU 성능을 위한 최선의 해결책은 워커 스레드다. 브라우저는 예전 부터 워커의 개념을 가지고 있었다. 워커스레드는

- 한개의 프로세스
- 여러개의 스레드
- 스레드 당 한개의 이벤트 루프
- 스레드 당 한개의 자바스크립트 엔진 인스턴스
- 스레드 당 한개의 Nodejs 인스턴스

를 가질 수 있다.

![worker](https://images.ctfassets.net/hspc7zpa5cvq/20h5efXHT4bQbuf44mdq2H/a40944191d031217a9169b17a8ef35d6/worker-diagram_2x__1_.jpg)

`worker_threads` 모듈은 자바스크립트를 병렬로 실행할 수 있는 여러개의 스레드를 사용할 수 있게 해준다.

```javascript
const worker = require('worker_threads')
```

워커 스레드는 10부터 사용가능하지만, 여전히 실험적인 기능으로 남아 있다. (experimental phase)

이상적인 것은, 동일한 프로세스 내에 여러 Node.js 인스턴스를 두는 것이다. 워커 스레드를 활용하면, 스레드가 같은 시점에서 종료될 수 있으며, 부모 프로세스가 종료되는 것을 기다릴 필요가 없다. 워커 사용이 끝난 이후에도 워커의 리소스가 남아있는 것은 리소스 관리 측면에서 좋지 못하다. 이는 메모리 누수로 이어질 수 있으며, 우리는 이를 원치 않는다. 따라서 Nodejs에 이를 내장하고, Nodejs에 새로운 스레드를 만든다음, 그 스레드 안에 새로운 Nodejs인스턴스를 만들 수 있는 기능을 부여하고 싶다. 기본적으로 동일한 프로세스 내에서 독립된 스레드를 실행한다.

스레드는 아래와 같은 특징을 가지고 있다.

- `ArrayBuffers` 메모리를 스레드에서 다른 스레드로 이동
- `SharedArrayBuffer` 여러 스레드에서 동시에 접근 가능. 스레드간에 메모리 공유가 가능해짐 (바이너리 데이터에 한함)
- `Atomics` 일부 프로세스를 동시에 좀더 효율적으로 처리할 수 있으며, 자바스크립트에서 조건변수를 구현할 수 있도록 한다.
- `MessagePort` 다른 스레드 사이에서 통신을 할 때 사용. 구조화된 데이터, 메모리 리전, 다른 메시지 포트를 다른 워커 간에 공유할 수 있다.
- `MessageChannel`: 비동기 양방향 통신을 위해 사용
- `WorkerData`:

https://nodesource.com/blog/worker-threads-nodejs
