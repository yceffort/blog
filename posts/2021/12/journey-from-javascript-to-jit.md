---
title: ''
tags:
  - javascript
  - web  
  - browser
published: true
date: 2021-12-08 19:45:17
description: ''
---

## Table of Contents

## 바이트코드 번들

요즘 모던 웹 애플리케이션의 경우, 브라우저가 최초로 보게되는 자바스크립트는 사실 우리가 알고 있는 개발자가 작성한 자바스크립트가 아니다. 일반적으로 브라우저가 처음 마주하는 자바스크립트는 webpack과 같은 도구에 의해 생산된 번들 파일일 것이다. 그리고 이 번들에는 리액트와 같은 ui 프레임워크, 그리고 다양한 polyfill, 그리고 npm을 통해 제공되는 다양한 패키지들이 포함된 다소 큰 번들일 것이다. 브라우저에 존재하는 자바스크립트 엔진의 첫번째 임무는 이렇게 받은 큰 자바스크립트 텍스트 묶음을 가상머신에서 실행할 수 있는 명령어로 변환하는 것이다. 자바스크립트 엔진은 코드를 파싱해야 하는데, 사용자가 자바스크립트에서 인터랙션을 기다리고 있기 때문에 이 작업을 빠르게 할 필요가 있다.

높은 수준에서, 자바스크립트엔진은 다른 프로그래밍 언어 컴파일러처럼 코드를 파싱한다. 먼저 자바스크립트 코드 텍스르트를 토큰이라고 불리는 청크로 나눈다. 각 토큰은 일반적인 우리 언어와 유사하게 구문 구조내에서 의미있는 단위로 쪼개진다. 그런 다음 이 토큰들은, 프로그램을 나타내는 트리구조를 생성하는 탑다운 파서로 공급된다. 자바스크립트 언어 디자이너와 컴파일러 엔지니어들은 이 트리 구조를 [AST (abstract syntax tree)](https://gyujincho.github.io/2018-06-19/AST-for-JS-devlopers) 라고 부른다. 그 결과 AST를 분석하여 바이트 코드라고 불리는 가상 머신 명령어 목록을 생성할 수 있다.

![js-ast-bytecode](https://i0.wp.com/alistapart.com/wp-content/uploads/2018/11/fig1.png?w=960&ssl=1)

AST를 생성하는 과정은 자바스크립트에서 비교적 간단한 임무 중 하나다. 그러나 불행하게도, 이 작업은 느릴 수 있다. 자바스크립트 엔진은 사용자가 인터랙션을 시작하기전에 전체 번들에 대한 구문 트리를 분석하고 빌드해야 한다. 이러한 코드의 대부분은 초기 페이지 로딩에 불필요할 수 있으며, 일부는 아예 실행되지도 않을 수도 있다.

다행히도(?) 컴파일러 엔지니어들은 이러한 느린 속도를 높이기 위해 다양한 트릭을 만들었다. 먼저, 일부 엔진들은 백구라운드 스레드에서 코드를 파싱하여 다른 작업을 위한 메인 UI 스레드를 확보한다. 그리고 요즘 모던 엔지는 지연 구문 분석 또는 지연 컴파일이라는 기술을 사용하여 가능한 장시간 메모리 내 구문 트리 생성을 지연한다. 이 동작 방법을 간단히 살펴보자. 엔진이 한동한 실행 되지 않게 될 함수를 보게 되면, 함수 몸체를 가능한 빠르게 'throwaway' 한다. 나중에, 이 함수를 처음으로 호출하게 되면 코드가 다시 파싱된다. 이 때 엔진은 실행에 필요한 전체 AST 및 바이트를 생성한다. 자바스크립트의 세계에서는, 어떤 것을 두번하는 것이 한번하는 것보다 빠를 때도 종종있다.

여기서 가장 좋은 최적화는, 우리가 어떤 작업이든 바이패스 할 수 있게 해주는 것이다. 자바스크립트 컴파일에서는 파싱 단계를 완전히 건너뛴다. 일부 자바스크립트 엔진은 사용자가 사이트를 다시 방문할 경우 나중에 재사용할 수 있도록 생성된 바이트 코드를 캐시하려고 시도한다. 물론 이는 말처럼 간단하지 않다. 자바스크립트 번들은 웹사이트가 업데이트 됨에 따라서 자주 변경될 수 있으며, 브라우저는 캐싱에 오는 성능 향상과 비교해서 바이트코드를 직렬화하는 비용을 신중히 따져 봐야 한다.

## 바이트코드 런타임

이제 바이트 코드를 획득했으니 실행할 준비가 되었다. 